# Вопрос 5: 

---
  
- ## [Расскажите о наследовании в С++.](#title1) 
- ## [В чем разница между приватным и публичным наследованием?](#title2)
- ## [Каковы правила видимости полей и методов родителя в теле наследника, как явно обратиться из наследника к полям и методам родителя?](#title3) 
- ## [Что такое “срезка при копировании”?](#title4) 
- ## [Какие неявные конверсии разрешены между родителями и наследниками, в т.ч. ссылками (указателями) на них?](#title5) 
- ## [Какой порядок вызова конструкторов и деструкторов при наследовании?](#title6) 
- ## [Расскажите про модификатор доступа protected.](#title7) 
- ## [Расскажите про размещение объектов в памяти при наследовании.](#title8)

---

### <a id="title1">Расскажите о наследовании в С++.</a>

__ОПР:__ _Наследование_ — это концепция объектно-ориентированного программирования, согласно которой абстрактный тип данных может наследовать данные и функциональность 
некоторого существующего типа, способствуя повторному использованию компонентов программного обеспечения.

Допустим у нас есть дрон и пульт от него. Пульт и дрон обмениваются некими сообщениями по какому-нибудь каналу связи (например WiFi). 
Каждое сообщение в коде представляет собой некий класс, в котором перечислены поля, а так же каждое сообщение умеет возвращать свое байтовое представление и конструироваться из байтов.

Очевидно, что сообщений разных очень много. Например ControlMsg позволяет контролировать направление полета, StatusMsg позволяет узнавать статус дрона и тд.
Нам нужно написать функцию для отправки сообщения на пульт и функцию (хендлер) для принятия сообщения. Писать такой метод для каждого отдельного класса сообщения было бы странно. 
Да и видно, что у сообщений есть много общего. Тут нам пригодится наследование.

Напишем класс AbstractMsg в который унесем всю общую функциональность и от него уже будем наследовать каждое конкретное сообщение, которое будет расширять функционал AbstractMsg

```c++
struct Base {
  void f() {
    std::cout << 1;
  }
};

struct Derived: Base {
  void g() {
    std::cout << 2;
  }
};

int main() {
  Derived d;
  d.f();
  d.g();
}
```

---

### <a id="title2">В чем разница между приватным и публичным наследованием?</a>

Модификатор наследования влияет на то, с каким модификатором будут поля и методы родителя в наследнике:

1. Public оставляет все как было
2. Private меняет все на private
3. Protected меняет публичное на protected остальное оставляет как было

При этом к private полям родителя наследник не может обращаться даже если наследование публичное. К protected полям класса может обращаться сам класс и его наследники.
Давайте подведем итог:

1. Public наследование - факт наследования известен всем
2. Protected наследование - факт наследования известен наследнику и его наследникам
3. Private наследование - факт наследования известен только наследнику

__! Замечание__ По умолчанию у _структур_ public у _классов_ private.

Модификатор наследования задается следующим синтаксисом:

```c++
struct Base {
  void f() {
    std::cout << 1;
  }
};

struct Derived: public Base {
  void g() {
    std::cout << 2;
  }
};
```

---

### <a id="title3">Каковы правила видимости полей и методов родителя в теле наследника, как явно обратиться из наследника к полям и методам родителя?</a>

Посмотрим на следующий пример:

```c++
struct Base {
  void foo() {
    std::cout << 1;
  }
};

struct Dervided {
  void foo() {
    std::cout << 2;
  }
};

int main() {
  Derived d;
  d.foo();
}
```

Логично что на экран выведется 2. Если бы мы создали Base вывелось бы 1.
Теперь другая ситуация:

```c++
struct Base {
  int x = 1;
};

struct Dervided {
  int x = 2;
};

int main() {
  Derived d;
  d.x;
}
```

Тут все тоже без сюрпризов, выберется x который объявлен в Derived. На самом деле в Derived будет присутствовать два поля x, просто второе затмит первое. Можно явно обратиться к x родителя:

```c++
struct Base {
  int x = 1;
};

struct Dervided {
  int x = 2;
};

int main() {
  Derived d;
  d.Base::x;
}
```

С методом аналогично. Теперь давайте посмотрим на пример когда методы принимают разные параметры:

```c++
struct Base {
  void foo() {
    std::cout << 1;
  }
};

struct Dervided {
  void foo(int) {
    std::cout << 2;
  }
};

int main() {
  Derived d;
  d.foo();
}
```

Неожиданно будет CE, хотя в Derived есть foo которая не принимает параметров (унаследованная), но так работает поиск имен: метод foo в Derived затмил метод foo родительский

---

### <a id="title4">Что такое “срезка при копировании”?</a>

Публичное наследование позволяет нам приводить ребенка к родителю
Давайте посмотрим на код:

```c++
struct Base {
  int x;
};

struct Derived: Base {
  int y;
};

void f(Base b) {

}

void g(Base& b) {

}

int main() {
  Derived d;
  f(d);
  g(d);
}
```

В случае вызова f мы сконструируем новый объект типа Base от того объекта Base который хранится внутри Derived (то есть происходит срезка данных). 
В случае вызова g мы просто будем ссылаться на объект Base который находится внутри Derived.

Это влечет за собой следующую проблему: а что если Base поддерживает метод, который нелогично применять к Derived. Например: многоугольник и прямоугольник. 
Прямоугольник конечно же является частным случаем многоугольника, но в многоугольнике можно написать метод, который будет сдвигать одну из точек в произвольную точку. 
А вот в прямоугольнике такой метод невозможен (нарушатся свойства). Существует следующий принцип разработки ООП кода:

__ОПР:__ Принцип подстановки _Барбары Лисков_: 

Пусть q(x) является свойством, верным относительно объектов x некоторого типа T. Тогда q(y) также должно быть верным для объектов y типа S, где S является подтипом типа T.

__Простым языком__: объект наследника должно быть всегда можно воспринимать как объект родителя. То есть если есть какой-то код, который ожидает 
получить Base а мы отдаем ему Derived то все должно работать нормально.

Принцип Лисков входит в принципы [SOLID](https://ru.wikipedia.org/wiki/SOLID_(объектно-ориентированное_программирование))

---

### <a id="title5">Какие неявные конверсии разрешены между родителями и наследниками, в т.ч. ссылками (указателями) на них?</a>

При приватном (и защищенном) наследовании касты работать не будут (напомним, что приватное наследование запрещает внешним функциям использовать факт наследования).
Теперь поговорим про обратный каст.

```c++
int main() {
  Base b;
  Derived& d = static_cast<Derived&>(b);
  Derived* d_ptr = static_cast<Derived*>(&b);
}
```

Так кастовать можно только ссылки и указатели (потому что непонятно как создать _Derived_ из _Base_). Это опасная операция, потому что будет __UB__. 
Это не __UB__ если было бы вот так:

```c++
int main() {
  Derived d;

  Base& b_ref = d;
  Base* b_ptr = &d;

  Derived& d_ref = static_cast<Derived&>(b_ref);
  Derived* d_ptr = static_cast<Derived*>(b_ptr);
}
```

То есть каст вниз по иерархии это не __UB__ если изначально там объект типа _Derived_.
Такие касты опять же работают только если наследование публичное. Если наследование приватное, то сработает только _reinterpret_cast_.

---

### <a id="title6">Какой порядок вызова конструкторов и деструкторов при наследовании?</a>

Очевидно что при создании объекта Derived должен сначала как-то создаться объект типа Base.
Если явно не указано какой конструктор Base вызвать то вызовется конструктор по умолчанию. Давайте посмотрим на следующий пример:

```c++
struct Base {
  Base() {std::cout << "B"; }
};

struct Derived: Base {
  Derived() {std::cout << "D"; }
};

int main() {
  Derived b;
}
```

Деструкторы же вызываются в обратном порядке.
Давайте посмотрим на более сложный пример с полями:

```c++
struct A {
  A() {std::cout << "A\n"; }
  ~A() {std::cout << "~A\n"; }
};

struct B {
  B() {std::cout << "B\n"; }
  ~B() {std::cout << "~B\n"; }
};

struct Base {
  Base() {std::cout << "Base\n"; }
  ~Base() {std::cout << "~Base\n"; }

  A a;
};

struct Derived: Base {
  Derived() {std::cout << "Derived\n"; }
  ~Derived() {std::cout << "~Derived\n"; }

  B b;
};

int main() {
  Derived d;
}
```

Вывод будет такой:

A

Base

B

Derived

~Derived

~B

~Base

~A

То есть сначала создаются все поля Base, потом сам Base, потом поля Derived, потом сам Derived. Разрушение же происходит в обратном порядке.
Конечно же можно явно указать какой конструктор родителя мы хотим вызвать. Например:

```c++
struct Base {
  Base(int a) {}
};

struct Derived {
  Derived(int a, double d): Base(a), d_(d) {}

  double d_;
};
```

---

### <a id="title7">Расскажите про модификатор доступа protected.</a>

[смотерть выше](#title2)

---

### <a id="title8">Расскажите про размещение объектов в памяти при наследовании.</a>

Давайте посмотрим на следующий код:

```c++
class Base {
  int a;
  char b;
};

class Derived {
  double c;
};
```

Тогда объект Derived будет в памяти выглядеть следующим образом:

4 байта int

1 байт char

3 байта пропущено для выравнивания

8 байт double

То есть сначала расположены поля родителя, потом свои поля. Если бы в объекте Base не было полей, то Derived состоял бы просто из одного double

---

