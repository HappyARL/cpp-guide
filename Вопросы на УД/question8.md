# Вопрос 8: 

---

- ## [Что такое итераторы?](#title1) 
- ## [Какие виды итераторов бывают и какие операции допустимы над каждым из них?](#title2)

---

### <a id="title1">Что такое итераторы?</a>

__ОПР:__ _Итератор_ — это объект, который может перебирать элементы в контейнере стандартной библиотеки С++ и предоставлять доступ к отдельным элементам. 
Все контейнеры стандартной библиотеки С++ предоставляют итераторы, чтобы алгоритмы могли получить доступ к их элементам стандартным способом, 
независимо от типа контейнера, в котором сохранены элементы.

Для итератора минимум нужно:
- возможность себя разименовать
- возможность передвигаться (++)

Пример итератора:

```c++
vector<int> vec{ 0,1,2,3,4 };
for (auto it = begin(vec); it != end(vec); it++) {
    // Access element using dereference operator
    cout << *it << " ";
}
```

Тот же код используя _range-based for_ кострукцию:

```c+++
for (auto num : vec) {
    // no dereference operator
    cout << num << " ";
}
```

---

### <a id="title2">Какие виды итераторов бывают и какие операции допустимы над каждым из них?</a>

Существует [5 категорий итераторов](https://en.cppreference.com/w/cpp/iterator) (до С++17), который имеют свой функционал:

1. ___Выход [(LegacyOutputIterator)](https://en.cppreference.com/w/cpp/named_req/InputIterator)___. Выходной итератор X может выполнять переадресацию последовательности с помощью ++ оператора и может записывать элемент только один раз с помощью * оператора .

   _ПРИМЕР: std::ostream_iterator_

2. ___Вход [(LegacyInputIterator)](https://en.cppreference.com/w/cpp/named_req/OutputIterator)___. Входной итератор X может выполнять переадресацию последовательности с помощью ++ оператора и считывать элемент любое количество раз с помощью * оператора.
   Можно сравнить входные итераторы с помощью операторов == и != . После увеличения любой копии входного итератора ни одна из других копий не может быть безопасно сравнивается,
   разыменовывается или увеличивается.

   _ПРИМЕР: std::istream_

2. ___Однонаправленный [(LegacyForwardIterator)](https://en.cppreference.com/w/cpp/named_req/ForwardIterator)___. Итератор X прямого взаимодействия может выполнять итерацию вперед по последовательности с помощью оператора ++ и
   может считывать любой элемент или записывать элементы, не являющиеся константными, любое количество раз с помощью * оператора .
   Вы можете получить доступ к элементам элемента с помощью -> оператора и сравнить итераторы пересылки == с помощью операторов и != .
   Вы можете сделать несколько копий однонаправленного итератора, каждая из которых может быть разыменована и для нее может быть выполнено независимое приращение.
   Итератор прямого перенаправления, инициализируемый без ссылки на какой-либо контейнер, называется итератором перенаправления со значением NULL.
   Пустые однонаправленные итераторы всегда равны.

   _ПРИМЕР: forward_list, unordered_map/set_

4. ___Двунаправленный [(LegacyBidirectionalIterator)](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator)___. Двунаправленный итератор X может занять место прямого итератора. Однако можно также уменьшать двунаправленный итератор,
   как в --X, X-- или (V = *X--). Получить доступ к членам элементов и сравнить двунаправленные итераторы можно так же, как и однонаправленные итераторы.

   _ПРИМЕР: list, map/set_

5. ___Случайный доступ [(LegacyRandomAccessIterator)](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator)___. Итератор X произвольного доступа может занять место двунаправленного итератора.
   С помощью итератора произвольного доступа можно использовать оператор [] subscript для доступа к элементам.
   Операторы , -+= и -= можно использовать + для перемещения вперед или назад указанного числа элементов, а также для вычисления расстояния между итераторами.
   Можно сравнивать двунаправленные итераторы с помощью ==, !=, <, >, <=и >=.

   _ПРИМЕР: vector, deque_

---
