# Вопрос 6: 

---

- ## [Что такое виртуальные методы и чисто виртуальные методы?](#title1) 
- ## [Что такое абстрактный класс?](#title2)
- ## [Что такое полиморфизм?](#title3) 
- ## [Какой полиморфизм реализуют виртуальные методы?](#title4)
- ## [Зачем нужен виртуальный деструктор?](#title5)
- ## [Зачем нужно ключевое слово override и final?](#title6)

---

### <a id="title1">Что такое виртуальные методы и чисто виртуальные методы?</a>

__ОПР:__ _Виртуальные методы_ - это методы, которые могут быть переопределены в производных классах. 
При вызове виртуального метода через указатель на базовый класс будет вызвана соответствующая реализация в производном классе.

__ОПР:__ _Чисто виртуальные методы_ - это виртуальные методы, для которых не предусмотрена реализация в базовом классе. 
Они объявляются с помощью ключевого слова "virtual" и знака " = 0" в конце объявления метода.

---

### <a id="title2">Что такое абстрактный класс?</a>

__ОПР:__ Класс который хотя бы имеет один чисто виртуальный метод называется _абстрактным_.

Создать объект абстрактного класса нельзя, это CE. Можно лишь заводить указатели на него и ссылки (а мы этого и добиваемся). 
Если наследник не переопределит все чисто виртуальные методы родителя, то наследник тоже будет считаться абстрактным классом.

---

### <a id="title3">Что такое полиморфизм?</a>

__ОПР:__ _Полиморфизм_ - это способность функции обрабатывать данные разных типов. (За одним интерфейсом скрываются разные реализации)

С полиморфизмом мы уже несколько раз встречались:
- Перегрузка функций
- Шаблоны

Это примеры статического полиморфизма (все разрешается на этапе компиляции)

---

### <a id="title4">Какой полиморфизм реализуют виртуальные методы?</a>

__ОПР:__ Виртуальные методы реализуют полиморфизм времени выполнения (runtime polymorphism), который позволяет вызывать методы объектов 
разных классов через указатель на базовый класс, что обеспечивает более гибкую и удобную работу с объектами.

Иногда понять на этапе компиляции какой на самом деле тип невозможно, например:

```c++
struct Base {};
struct Derived: Base {};

int main() {
  int x;
  std::cin >> x;
  Base b;
  Derived d;
  Base& b_ref = x % 2 == 0 ? b : d;
}
```

В compile time понять что на самом деле лежит под b_ref невозможно.
То есть иногда валидно ли приводить типы можно понять только на этапе выполнения. Для этого и нужен _dynamic_cast_:

```c++
struct Base {};
struct Derived: Base {};

int main() {
  int x;
  std::cin >> x;
  Base b;
  Derived d;
  Base& b_ref = x % 2 == 0 ? b : d;

  dynamic_cast<Derived&>(b);
}
```

Сейчас будет __CE__, потому что _dynamic_cast_ требует чтобы объекты были полиморфными (то есть должна быть хотя бы одна виртуальная функция).

```c++
struct Base {
  virtual ~Base() = default;
};
struct Derived: Base {};

int main() {
  int x;
  std::cin >> x;
  Base b;
  Derived d;
  Base& b_ref = x % 2 == 0 ? b : d;

  dynamic_cast<Derived&>(b);
}
```

Сейчас если мы введем четное число то все будет работать нормально. Если введем нечетное число, то выбросится исключение std::bad_cast. 
Как работать с исключениями мы пока не знаем, поэтому давайте кастить не ссылки а указатели:

```c++
struct Base {
  virtual ~Base() = default;
};
struct Derived: Base {};

int main() {
  int x;
  std::cin >> x;
  Base b;
  Derived d;
  Base& b_ref = x % 2 == 0 ? b : d;

  Derived* ptr = dynamic_cast<Derived*>(&b);
}
```

Если каст будет удачным, то вернется указатель. Если нет, то вернется nullptr.

_dynamic_cast_ так же позволяет делать касты "вбок". То есть:

```c++
struct Mother {};
struct Father {};
struct Son: Mother, Father {};

int main() {
  Son s;
  Mother& m = s;
  Dad& d = dynamic_cast<Dad&>(m);
}
```

---

### <a id="title5">Зачем нужен виртуальный деструктор?</a>

Давайте посмотрим на следующий код:

```c++
struct Base {};

struct Derived {
  Derived() {
    array = new int[10];
  }

  int* array;
};

int main() {
  Base* b = new Derived();
  delete b;
}
```

Сейчас у нас произойдет утечка памяти, потому что вызовется деструктор Base (который ничего не делает) а деструктор Derived не вызовется.
Поэтому при наследовании стоит делать деструктор виртуальным:

```c++
struct Base {
  virtual ~Base() = default;
};

struct Derived {
  Derived() {
    array = new int[10];
  }

  int* array;
};

int main() {
  Base* b = new Derived();
  delete b;
}
```

---

### <a id="title6">Зачем нужно ключевое слово override и final?</a>

Давайте посмотрим на такой пример:

```c++
struct Base {
  virtual void f() { std::cout << 1; }
}

struct Derived: Base {
  void f() const {std::cout << 2; }
}

int main() {
  Derived d;
  Base& b = d;
  b.f();
}
```

Выведется 1, потому что механизм виртуальных функций работает только тогда, когда точно совпадает сигнатура.

Чтобы не ошибаться можно (и нужно) использовать ключевое слово _override_

```c++
struct Base {
  virtual void f() { std::cout << 1; }
}

struct Derived: Base {
  void f() const override {std::cout << 2; }
}

int main() {
  Derived d;
  Base& b = d;
  b.f();
}
```

Сейчас будет CE, потому что мы сказали что переопределяем какую-то виртуальную функцию родителя (использовали override), но виртуальной функции с такой сигнатурой в родителе нет.
Если убрать const то все заработает (или добавить const в родительский метод).

Есть еще ключевое слово _final_, которое запрещает наследникам переопределять эту виртуальную функцию:

```c++
struct Base {
  virtual void f() { std::cout << 1; }
}

struct Derived: Base {
  void f() final {std::cout << 2; }
}

struct SubDerived: Derived {
  void f() { std::cout << 3; }
}

int main() {
  SubDerived sd;
  Base& b = sd;
  b.f();
}
```

Будет CE (потому что в SubDerived переопределяется функция, которая была помечена final в родителе)
Теперь давайте посмотрим что будет с приватным методом:

```c++
struct Base {
  virtual void f() { std::cout << 1; }
}

struct Derived: Base {
private:
  void f() override {std::cout << 2; }
}

int main() {
  Derived d;
  Base& b = d;
  b.f();
}
```

CE не будет и выведется 2, потому что приватность проверяется на этапе компиляции, а в RE понятия приватности уже не существует. На этапе компиляции с приватностью все ок (f публичный метод Base).

---
