# Вопрос 2: 

---

- ## [Расскажите о том, что такое классы, объекты, члены классов, поля, методы, модификаторы доступа, инкапсуляция.](#title1) 
- ## [Расскажите про конструкторы и деструкторы, операторы присваивания, “правило трех”, про генерацию компилятором этих методов.](#title2)
- ## [Что такое списки инициализации в конструкторах и делегирующие конструкторы, зачем они нужны?](#title3) 
- ## [Приведите пример ситуации, когда нужен нетривиальный конструктор и деструктор.](#title4)
- ## [Расскажите про операторы * и ->.](#title5)
- ## [Расскажите о том какие операторы можно перегружать для класса.](#title6)
- ## [В чем неудобство перегрузки арифметических операторов внутри класса?](#title7)

---

### <a id="title1">Расскажите о том, что такое классы, объекты, члены классов, поля, методы, модификаторы доступа, инкапсуляция.</a>

__ОПР:__ _Класс_ - это пользовательский тип данных, который появляется в последовательности-спецификаторов-объявления синтаксиса объявления.
Класс может иметь следующие данные:
  1. элементы данных (далее поля)
  2. функции-элементы (далее методы)
  3. вложенные типы
  4. перечислители
  5. шаблоны элементов

```c++
// пример класса
class Student {
 private:
  int age;
  std::string name;

 public:
  int get_age() { return age; }
  std::string get_name() { return name; }
};

int main() {
  Student student; // student - объект
  std::cout << student.get_name() << " " << student.get_age() << '\n';
  return 0;
}
```

__ОПР:__ _Объекты_ - это экземпляры классов, которые имеют свои уникальные значения свойств и методов.

__ОПР:__ _Члены классов_ - это поля и методы, которые определяют состояние и поведение объектов.

__ОПР:__ _Поля_ - это переменные, которые хранят данные объекта.

__ОПР:__ _Методы_ - это функции, которые определяют поведение объекта.

```c++
class Student {
 private:
  int age; // поле
  std::string name; // поле

 public:
  int get_age() { return age; } // метод
  std::string get_name() { return name; } // метод
};
```

__ОПР:__ _Модификаторы доступа_ - это ключевые слова, которые определяют уровень доступа к членам класса. 
Существуют три модификатора доступа: public, private и protected.

```c++
class Student {
 private:
  // доступен только самому классу

 public:
  // доступен всем из-вне

 protected:
  // доступен только наследникам этого класса
};
```

__ОПР:__ _Инкапсуляция_ - это принцип ООП, который заключается в том, что данные и методы объекта скрыты от 
внешнего мира и доступны только через интерфейс объекта. Это позволяет защитить данные объекта от неправильного 
использования и изменения.

__! Замечание__ Ключевое слово _friend_ делает другую функцию/класс другом нашего класса и тогда можно выдать доступ к приватным полям.

```c++
class Student {
 // code
 friend void botay();
};

void botay() {
  std::cout << "я ботаю с++" << '\n';
}

int main() {
  Student student; // student - объект
  std::cout << student.get_name() << " " << student.get_age() << '\n'; // получили доступ к скрытым полям через методы
  std::cout << student.name << " " << student.age << '\n'; // СЕ так как мы обращаемся в приватные поля
  student.botay();
  return 0;
}
```

---

### <a id="title2">Расскажите про конструкторы и деструкторы, операторы присваивания, “правило трех”, про генерацию компилятором этих методов.</a>

__ОПР:__ _Конструктор_ - это специальная нестатический метод класса, который используется для инициализации объектов своего классового типа.

```c++
Student();
```

__ОПР:__ _Конструктор копирования_ - это специальный конструктор, применяемый для создания нового объекта как копии уже существующего. 
Такой конструктор принимает как минимум один аргумент: ссылку на копируемый объект.

```c++
Student(const Student& copy);
```

__ОПР:__ _Деструктор_ - это специальная функция-элемент, которая вызывается, когда заканчивается время жизни объекта. Цель деструктора освободить ресурсы, 
которые объект мог получить за время своего существования.

```c++
~Student();
```

__ОПР:__ _Оператор присваивания (=)_ приводит к тому, что значение второго операнда сохраняется в объекте, указанном первым операндом.

__ОПР:__ _Оператор присваивания копированием_ также используется для присваивания значения одной переменной другой, 
но он определен внутри класса и позволяет копировать значения всех полей объекта.

```c++
Student& operator=(const Student& other);
```

__ОПР:__ Если классу требуется пользовательский _деструктор_, пользовательский _конструктор копирования_ или 
пользовательский _оператор присваивания копированием_, он почти наверняка требует все три.

```c++
class Student {
 public:
  // Правило трех
  Student(const Student& copy); // I
  ~Student(); // II
  Student& operator=(const Student& other); // III
};
```

__! Замечание 1__ Компилятор может генерировать _конструкторы_, _операторы присваивания_ и _деструкторы_ автоматически, если они не определены явно. 
Однако, если класс имеет какие-то особенности (например, динамическое выделение памяти), то компилятор может не справиться 
с их автоматической генерацией, и нужно определить эти методы самостоятельно.

__! Замечание 2__ Если существует хотя бы один написанный вами конструктор компилятор перестает генерировать конструктор по умолчанию.

__! Замечание 3__ Конструктор копирования генерируется компилятором автоматически, даже если определены другие конструкторы.

---

### <a id="title3">Что такое списки инициализации в конструкторах и делегирующие конструкторы, зачем они нужны?</a>

__ОПР:__ _Список инициализации в конструкторах_ - это специальный синтаксис, который позволяет инициализировать поля и базовые классы объекта при его создании. 
Синтаксис которого представляет собой символ двоеточия :, за которым следует разделённый запятыми список одного или нескольких инициализаторов-элементов.

```c++
Student(int num, std::string word) : age(num), name(word) { }
```

__ОПР:__ _Делегирующие конструкторы_ - это специальные конструкторы, которые вызывают другой конструктор в том же классе. 
Они позволяют избежать дублирования кода, когда несколько конструкторов имеют общую часть кода. Синтаксис такой же как у списка инициализации.

```c++
class Student {
 public:
  Student(int num) {
    std::cout << num << '\n';
  }

  Student(int num, std::string word) : Student(num) {
    // Student(num) - неверно так как просто создадим еще один объект
  }
};
```

__! Замечание__ Списки инициализации и делегирующие конструкторы помогают упростить код и сделать его более читаемым. Они также могут улучшить производительность, 
поскольку позволяют избежать лишних операций и инициализировать объекты более эффективно.

---

### <a id="title4">Приведите пример ситуации, когда нужен нетривиальный конструктор и деструктор.</a>

У нас есть класс который использует конструктор для выделения памяти, а деструктор для ее освобождения.

```c++
class Class {
 public:
  Class() {
    // allocate / new
  }

  ~Class() {
    // deallocate / delete
  }
};
```

---

### <a id="title5">Расскажите про операторы * и ->.</a>

__ОПР:__ _Оператор *_ используется для доступа к объекту, на который указывает указатель. Например, если у нас 
есть указатель на объект класса, мы можем получить доступ к его членам с помощью оператора *. Например:

```c++
class MyClass {
public:
    int myInt;
};

MyClass* ptr = new MyClass();
ptr->myInt = 42;

std::cout << (*ptr).myInt << std::endl; // Выводит 42
```

__ОПР:__ _Оператор ->_ используется для доступа к членам объекта класса через указатель на этот объект. 
Он является сокращенной записью для операции (*ptr).member. Например:

```c++
class MyClass {
public:
    int myInt;
};

MyClass* ptr = new MyClass();
ptr->myInt = 42;

std::cout << ptr->myInt << std::endl; // Выводит 42
```

Таким образом, операторы * и -> позволяют удобно работать с указателями на объекты классов и получать доступ к их членам.

---

### <a id="title6">Расскажите о том какие операторы можно перегружать для класса.</a>

Операторы, которые можно перегружать для класса, включают:

- Арифметические операторы (+, -, *, /, %)
- Операторы сравнения (==, !=, <, >, <=, >=)
- Операторы присваивания (=, +=, -=, *=, /=, %=)
- Операторы инкремента и декремента (++, --)
- Операторы битовых операций (&, |, ^, ~, <<, >>)
- Операторы логических операций (!, &&, ||)


---

### <a id="title7">В чем неудобство перегрузки арифметических операторов внутри класса?</a>

Неудобство перегрузки арифметических операторов внутри класса заключается в том, что они могут привести к неочевидному поведению и неожиданным результатам. 
Например, если перегрузить оператор + для класса, то его использование может привести к созданию нового объекта класса, что может быть нежелательным в некоторых ситуациях. 
Кроме того, перегрузка арифметических операторов может привести к увеличению сложности кода и усложнению его понимания. Поэтому в некоторых случаях лучше использовать 
обычные функции для выполнения арифметических операций над объектами класса.
