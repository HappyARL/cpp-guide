# Вопрос 11: 
 
---

- ## [Расскажите о выводе типов с помощью ключевого слова auto.](#title1) 
- ## [В каких контекстах можно использовать auto?](#title2)

---

### <a id="title1">Расскажите о выводе типов с помощью ключевого слова auto.</a>

__ОПР:__ _auto_ - это ключевое слово которое позволяет в некоторых местах не писать тип.

_аuto_ работает так же как вывод шаблонного типа. Оно понятное дело можно комбинировать со ссылками и константностью:

```c++
int main() {
  std::map<std::string, std::int> m;

  for (const auto& item : m) {
    ...
  }
}
```

auto как и с T работает отбрасывание ссылок, то есть при auto x = "чему-то со ссылкой" ссылка отбросится. Например:

```c++
int& foo(int& x) {return x; }

int main() {
  int x = 10;
  auto y = foo(x);
  ++y;
}
```

Рассмотрим такой код:

```c++
int& foo(int& x) {return x; }

int main() {
  int x = 10;
  auto&& y = foo(x);
  ++y;
}
```

И тут auto&& работает как универсальная ссылка, то есть тут работают все те же правила.

---

### <a id="title2">В каких контекстах можно использовать auto?</a>

Зачем это вообще нужно?

Посмотрим на следующий код:

```c++
int main() {
  std::map<std::string, std::int> m;

  for (std::map<std::string, std::int>::iterator it = m.begin(); it != m.end(); ++it) {
    ...
  }
}
```

И этот же код только с ключевым словом _auto_:

```c++
int main() {
  std::map<std::string, std::int> m;

  for (auto it = m.begin(); it != m.end(); ++it) {
    ...
  }
}
```

Еще пример:

```c++
int main() {
  std::map<std::string, std::int> m;

  for (const std::pair<std::string, int>& item : m) {
    ...
  }
}
```

item здесь будут копироваться, потому что внутри контейнера map лежат пары вида std::pair<const std::string, int>. Соответственно в этом случае тоже хорошо бы использовать auto.

Еще одна причина использовать auto: типы в коде могут поменяться и без auto это превратится в огромный рефакторинг

---
