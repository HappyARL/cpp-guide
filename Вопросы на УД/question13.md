# Вопрос 13: 

---

- ## [Что такое лямбда-функции в C++?](#title1) 
- ## [Каков синтаксис лямбда-выражений?](#title2)
- ## [Приведите пример использования лямбда функции.](#title3)

---

### <a id="title1">Что такое лямбда-функции в C++?</a>

__ОПР:__ _Лямбда-выражения_ - создаёт замыкание': безымянный функциональный объект, способный захватывать переменные в области видимости.

>___' замыкание — это функция, которая ссылается на свободные переменные в своей области видимости.___

Пусть у нас есть какой-то вектор и мы хотим его посортировать используя кастомный компаратор (давайте сравнивать инты по модулю 10)
Как это сделать если у нас нет лямбда функций:

```c++
struct Cmp {
  bool operator()(int x, int y) const {
    return x % 10 < y % 10;
  }
}

int main() {
  std::vector<int> v{1, 12, 1241, 124, 1, 123, 5342, 123};
  std::sort(v.begin(), v.end(); Cmp());
  for (auto value : v) {
    std::cout << value << " ";
}
```

Каждый раз создавать отдельную структуру (или функцию) в таких местах не очень хочется, поэтому давайте воспользуемся лямбда функциями

```c++
int main() {
  std::vector<int> v{1, 12, 1241, 124, 1, 123, 5342, 123};
  std::sort(v.begin(), v.end(), [](int x, int y) {return x % 10 < y % 10; });
  for (auto value : v) {
    std::cout << value << " ";
}
```

более подробно тут: [как объект и захват полей](https://gitlab.com/yaishenka/cpp_course/-/blob/main/lectures/lecture_18.md#3-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BA%D0%B0%D0%BA-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B)

---

### <a id="title2">Каков синтаксис лямбда-выражений?</a>

__ОПР:__ Синтаксис: [ захваты ] ( параметры ) спецификаторы ﻿(необязательно) requires ﻿(необязательно) { тело }

Лямбда функции это объекты, поэтому нашу функцию можно сохранить в переменную

```c++
int main() {
  auto f = [](int x, int y) {return x % 10 < y % 10; };
}
```

auto потому что компилятор сам сгенерирует название типа для этой функции, мы его сами не знаем (но можно посмотреть ради интереса)
Можно возвращать лямбда функции из функций

```c++
auto GetCompare() {
  return [](int x, int y) {return x % 10 < y % 10; };
}
```

Лямбда функции можно вызывать на месте

```c++
int main() {
  [](int x) { std::cout << x; }(10);
}
```

Возвращаемое значение лямбда функции определяется по правилам auto.

Возвращаемое значение можно указать явно:

```c++
auto f = [](int x, int y) -> bool {return x % 10 < y % 10; };
```

Иногда мы хотим в лямбда функциях обращаться к переменным объявленным снаружи. Вот такой код работать не будет:

```c++
int main() {
  int a = 10;

  [](int x) {
    std::cout << x * a;
  }(10);
}
```

Для такого "захвата" и отведены квадратные скобки в начале объявления лямбда функций:

```c++
int main() {
  int a = 10;
  int b = 20;
  int c = 30;

  [a, b, c](int x) {
    std::cout << x * a;
  }(10);
}
```

Что будет если внутри лямбда функции поменять захваченную переменную:

```c++
int main() {
  int a = 10;
  [a]() { a += 1; }();
  std::cout << a;
}
```

Этот код не скомпилируется, потому что по умолчанию захваченные переменные константные. Чтобы сделать их не константными воспользуемся ключевым словом mutable

```c++
int main() {
  int a = 10;
  [a]() mutable { a += 1; }();
  std::cout << a;
}
```

Это сделает все захваченные переменные не константными. Простого способа сделать конкретную переменную изменяемой нет.
Переменные можно захватывать по ссылке:

```c++
int main() {
  int a = 10;
  int b = 20;
  int c = 30;

  [&a, b, &c](int x) {
    std::cout << x * a;
  }(10);
}
```

При этом переменные a и c можно менять и это будет работать как обычная ссылка.
Еще можно захватить вообще все локальные переменные по значению

```c++
int main() {
  int a = 10;
  int b = 20;
  int c = 30;

  [=](int x) {
    std::cout << x * a;
  }(10);
}
```

---

### <a id="title3">Приведите пример использования лямбда функции.</a>

[пример](#title1) 

---
