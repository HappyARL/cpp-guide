# Вопрос 10: 

---

- ## [Расскажите о проблемах, для решения которых была введена move-семантика.](#title1) 
- ## [Расскажите как пользоваться функцией std::move.](#title2)
- ## [Расскажите как реализовать move-конструктор и move-оператор присваивания (на примере класса string).](#title3)
- ## [Как действует правило пяти? Как правильно реализовать функцию swap в C++11?](#title4)

---

### <a id="title1">Расскажите о проблемах, для решения которых была введена move-семантика.</a>

- Давайте посмотрим на функцию swap. Сейчас мы умеем писать ее так:

```c++
template <typename T>
void swap(T& first, T& second) {
  T tmp = first;
  first = second;
  second = tmp;
}
```

Заметим, что во всех трех строках происходит копирование. Если бы мы вызвали такую функцию от какого-нибудь вектора, то мы бы сделали три линейных прохода.

- Еще один пример:

Возьмем нашу реализацию вектора

```c++
int main() {
  vector<std::string> v;
  v.push_back(std::string("test"));
}
```

Тогда конструктор std::string вызовется дважды (потому что push_back вызывает конструктор). Опять лишнее копирование!

Эта проблема решается с помощью метода emplace_back:

```c++
int main() {
  vector<std::string> v;
  v.emplace_back("test");
}
```

Метод emplace_back принимает аргументы, из которых потом конструирует объект:

```c++
template <typename... Args>
void emplace_back(const Args&... args) {
  if (size_ == capacity_) {
    reserve(2 * capacity_);
  }

  new(arr + sz) T(args...);
  size_ += 1;
}
```

Такая реализация уже лучше, но мы все еще копируем аргументы. С текущим инструментарием мы эту проблему не решим.

- Еще один пример можно заметить в методе resize того же вектора. Там мы использовали следующий код:

```c++
std::uninitialized_copy(arr_, arr_ + size_, new_arr);
```

То есть опять делаем лишние копии. А мы хотим научиться просто "перекладывать" объекты.
Еще один примерчик (RVO нас тут не спасает):

```c++
std::string f() {
  return std::string("test");
}

int main() {
  std::vector<std::string> v;
  v.emplace_back(f());
}
```

---

### <a id="title2">Расскажите как пользоваться функцией std::move.</a>

Давайте перепишем наш swap:

```c++
template <typename T>
void swap(T& first, T& second) {
  T tmp = std::move(first);
  first = std::move(second);
  second = std::move(tmp);
}
```

Для большинства стандартных типов (movable-типов) все будет работать за О(1).

__ОПР:__ _std::move_ используется для указания того, что объект t может быть "перемещён из", т.е. позволяет эффективно передавать ресурсы из t в другой объект.

__Неформально:__ посмотрим на эту строчку T tmp = std::move(first); Здесь все "ресурсы" объекта first были отданы объекту tmp. Не скопированы, а просто перемещены.

Важные замечания:
- Если просто сделать std::move(object), и не присваивать ничего, то object останется таким каким и был (попозже поймем почему)
- Все стандартные типы гарантируют, что после auto x = std::move(y), y остается валидным (пустым почти наверное).

---

### <a id="title3">Расскажите как реализовать move-конструктор и move-оператор присваивания (на примере класса string).</a>

__ОПР:__ _move-конструктор [(Конструктор перемещения)](https://en.cppreference.com/w/cpp/language/move_constructor)_ 
        - это класса T это нешаблонный конструктор, первый параметр которого равен T&&, const T&&, volatile T&& или const volatile T&&, 
         и либо другие параметры отсутствуют, либо все остальные параметры имеют значения по умолчанию.

__ОПР:__ _move-оператор присваивания [(Оператор присваивания перемещения)](https://en.cppreference.com/w/cpp/language/move_assignment)_ 
          - это класса T это нешаблонная нестатическая функция-элемент с именем operator=, которая принимает точно один параметр 
          типа T&&, const T&&, volatile T&& или const volatile T&&.

___move-конструктор и move-оператор присваивания___ обычно "крадут" ресурсы, содержащиеся в аргументе, а не делают их копии и оставляют аргумент в каком-то действительном, 
но в остальном неопределённом состоянии. Например, перемещение из std::string или std::vector может привести к тому, что аргумент останется пустым. 
Однако на такое поведение не следует полагаться. Для некоторых типов, таких как std::unique_ptr, полностью определено состояние перемещения.

Давайте посмотрим на примере класса String:

> move-конструктор
```c++
class String {
 public:
  String(String&& s): str_(s.str_), size_(s.size_) {
    s.str_ = nullptr;
    s.size_ = 0;
  }

 private:
  char* str_ = nullptr;
  size_t size_ = 0;
}
```

> move-оператор присваивания
```c++
String operator=(String&& s) {
  String tmp = std::move(s);
  swap(tmp);
  reutrn *this;
}
```

---

### <a id="title4">Как действует правило пяти? Как правильно реализовать функцию swap в C++11?</a>

move-конструктор генерируется автоматически если нет user-declared move-конструктора и:
- Нет user-declared copy-конструкторов
- Нет user-declared операторов присваивания копированием
- Нет user-declared move-операторов копирования
- Нет user-declared деструктора

С move-оператором присваивания аналогично.

Из этого следует очевидное правило пяти (как правило трех, только еще два пункта добавили)

__! Замечание:__ _move-конструктор и move-оperator по умолчанию будут просто мувать все поля._ 

Давайте поймем почему такой конструктор будет плохим во многих случаях:

```c++
class String {
 public:
  String(String&& s) {
    s.str_ = std::move(s.str_);
    s.size_ = std::move(s.size_);
  }

 private:
  char* str_ = nullptr;
  size_t size_ = 0;
}
```

std::move от тривиальных объектов просто их копирует. То есть мы не обнулим указатель и размер у строки s, то есть сделаем __double free__ в какой-то момент.

---
