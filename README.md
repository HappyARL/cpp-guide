# cpp-guide

ПЕРЕМЕННЫЕ:
bool      [1 byte] - true \ false
char      [1 byte] - 1 символ (буквы алфавита \ цифры(символы) \ знаки )
{std::string - набор char-ов, т.е. строка}
int        [4 byte] - целые числа (1 24 256 1024)
float     [4 byte] - десятичные дроби (1,5 30,4 1254,92)
double  [8 byte] - как float но может хранить в 2 раза больше.
ВЫВОД:
std::cout << ... <<std::endl;  --  вывод чего либо в С++
не зависит от переменных и их количества
int age = 18;
bool student = true;
std::cout << "Hello, " << "Arlan! " << "You are " << age << " years old. " << "Status of student: " << student <<std::endl;

КОНСТАНТЫ:
float pi = 3.14159;
int radius = 10;
float c = 2 * pi * radius;
std::cout << c <<std::endl;

Проблема кода в том, что мы можем менять значение числа пи, тем самым сломать всю математику в нем. Воизбежения этого мы пишем const float PI = 3.14159;
Теперь если в коде мы захотим поменять значение числа пи, то компьютер будет выдавать ошибку. 

NAMESPACE:
namespace - это пространство имен(дословно). Это множество которое воспринимется как абстрактное хранилище или окружение, созданное для хранения определенных переменных, которые нужно обьевлять в основном коде.
std(standart) - это БАЗАвое пространство имен которое есть в стандартной библиотеке С++.
Теперь как работать с этими пространствами, допустим у нас есть студент 1 и 2, мы знаим их ИМЯ(name), ВОЗРАСТ(age) и СТРАНУ ОТ КУДА ПРИБЫЛИ(country). в одну и туже переменную name мы не можем внести два значения, а выделять доп память нерационально. Мы можем создать "протсранство" ака namespace для каждого студенты и при вызове переменной в функции main будем уточнять чья именно информация нам нужна:
namespace first_student{
    std::string name = "Arlan";
    int age = 18;
    std::string country = "Kazakhstan";
}
namespace second_student{
    std::string name = "Denis";
    int age = 18;
    std::string country = "Ukraine";
}

int main() {
    std::string name = "empty";
    int age = 0;
    std::string country = "none";
    std::cout << "Name: "<< second_student::name << "\n";
    std::cout << "Age: "<< second_student::age << "\n";
    std::cout << "Country: "<< second_student::country << "\n";
    return 0;
}

Тем самым мы можем уточнять чье имя нам нужно, приписав в name соответствующий namespace.
namespace (название){ наши переменные мо значениями }
в самом коде: (название namespace-a)::(переменная)
Кроме этого существует понятие using namespace (название простраства)
То есть если раньше переменная name принмала значение empty, то если добавить строчку 
using namespace first_student;
и удалим строки с дефолтными значениями, то за новый дефолт будет восприниматься значения первого студента. Так можно промернуть и со второрым, все выше упомянутые оперции сохраняются. 
TYPEDEF:
typedef - это способ задания нового типа данного. Например у нас большой код и нам лень все время писать std::string. Мы можем использовать вышеупомянутый namespace и просто убрать std, но это грозит перебоями в работе кода, так как в std очень много переменных которые могут смешаться с вашими (например data). Так что логичнее и безопаснее использовать typedef:
typedef std::string text_t;
int main() {
    text_t text = "empty";
 
Тут мы заменили длинный std::string на text_t (_t просто обозначение того что это typedef).  typedef (тип данных который надо заменить) (его новое название)
Альтернатива typedef это использование using вместо него, исход будет тот же:
using text_t = std::string;
int main() {
    text_t text = "empty";

ЗАПИСЬ И ВЫВОД ЗНАЧЕНИЙ:
Вывод нам уже давно известен это std::cout << ... ;
Ввод / запись будет осуществляться похожим методом std::cin >> ... ; {заметьте что стрелка повернута в противоположную сторону}
Осторожности выхывают во время записи строк, так как между словами будут пробелы, которые воспринимаются компьютером как конец строки.Для записи строк используют функцию std::getline(а,б), где а это std:cin , б это наша переменная. Пример такого кода:
int main() {
    int age;
    std::string name;
    std::cout << "What is your name?";
    std::getline(std::cin, name);
    std::cout << "How old are you?";
    std::cin >> age;
    std::cout << "Hello, "<< name << ". You are " << age << " year old!";
    return 0;
}

Единственное нужно уточнить, что если идет вначале запись одной переменной, а потом строки то может все сломаться, так как между данной переменной и строкой будет спрятанна \n которая воспринимается как строка для записи. Чтобы избежать этого надо чуток изменить функцию getline добавиви туда: >> std::ws (whitespaces ' '), данная операция удаляет \n и whitespaces тем самым ставя все на свои места.
БЫЛО: возраст  -- \n -- нужная строка
                 |             |                |
              age         name          none
СТАЛО: возраст -- нужная строка
                 |           |                
              age         name        
std::cout << "What is your name?";
std::getline(std::cin >> std::ws, name);

МАТЕМАТИЧЕСКИЕ ФУНКЦИИ:
В самом С++ есть уже готовый набор математических функций:
- MAX – std::max(a,b) – максимуму от двух чисел
- MIN – std::min(a,b) – минимум от двух чисел
Подключаем библиотек <cmath>:
- СТЕПЕНЬ – pow(a,b) – возведение числа a в степень b
- КОРЕНЬ – sqrt(a) – квадратный корень от числа а
- МОДУЛЬ – abs(a) – модуль от числа а
- ОКРУГЛЕНИЕ – round(a) – округление числа а
- ОКРУГЛЕНИЕ ВВЕРХ – ceil(a) – округления числа а вверх: 3,43 станет 4
- ОКРУГЛЕНИЕ ВНИЗ – floor(a) – округление числа а вниз: 3,43 станет 3

Еще много полезных мат. функций есть тут: https://cplusplus.com/reference/cmath/
ТЕРНАРНЫЙ ОПЕРТОР:
От латинского это тройной оператор, а имеет такое название потому что он представляет вид:
условие ? следствие 1 : следствие 2
Тем самым он заменяет конструкцию if /else. Пример использования:
int main() {
    int num;
    std::cout << "Enter your number:";
    std::cin >> num;
    if(num % 2 == 1)
        std::cout << "ODD";
    else
        std::cout << "EVEN";
    return 0;
}
это код с использование конструкции if/else, сейчас будет тот же код в тернарном виде:
int main() {
    int num;
    std::cout << "Enter your number:";
    std::cin >> num;
    num % 2 == 1 ? std::cout << "ODD" : std::cout << "EVEN" ;
}

УКАЗАТЕЛИ:
int main() {
    int year = 2022;
    int *pYear = &year; // &year - это адресс year
    std::cout << *pYear << std::endl; // 2022
    std::cout << pYear << std::endl;  // 0x96dfdffb84
}
Указатель должен быть того же типа, что и сама переменная. *(название) это указатель, чтобы он мог указывать на что то закрепим к нему адрес нужной переменной &(переменная).
Иногда на практике удобнее работать с адресами элементов нежели с ними самими. Пример: преподаватель передал вам результаты контрольной вашей группы, вместо того чтобы ходит к каждому и вручать лично. Легче сказать ГДЕ находятся результаты, тем самым освободив себя от этого «приключения».
int main() {
    std::string res[4] = {"res1", "res2", "res3", "res4"};
    std::string *pRes = res;
    std::cout << res << std::endl; //массив сам по себе и есть адресс на первый элемент
    std::cout << *pRes << std::endl; // смотрим что найдем если пойти по указателю
    std::cout << pRes << std::endl; // адрес указателя
}
ДИНАМИЧЕСКАЯ ПАМЯТЬ:
Мы уже знаем, что такое массив, но у него есть один минус, это то, что выделяет определенное количество памяти, которое потом никак не исправить. Например, у нас есть массив с 9-ью ячейками, допустим нам надо использовать только 5 из них, следовательно, мы просто так засорили память, выделив больше чем надо, и наоборот тоже, если нам не хватает места, мы теряем часть данных. 
Тогда мы используем динамическую память, разница в том что мы можем управлять ее размером и менять ее. Пример кода:
#include <iostream>

int main() {
    char *pGrades = NULL;
    int size;
    std::cout << "How many grades do you have? ";
    std::cin >> size;
    pGrades = new char[size];
    for(int i = 0 ; i < size ; i++) {
        std::cout << "Enter grade #" << i + 1 << ": " << std::endl;
        std::cin >> pGrades[i];
    }
    for(int i = 0 ; i < size ; i++) {
        std::cout << pGrades[i] << " " << std::endl;
    }
    delete pGrades;
    return 0;
}

Сначала мы создаем нулевой указатель, а затем «привязываем» к новому массиву размер который мы можем задать сами. В конце мы высвобождаем память функцией delete. 
Пример привязки указателей:
int main() {
    int *pNum = NULL;
    pNum = new int;
    *pNum = 21;
    std::cout << "adress: " << pNum << std::endl;
    std::cout << "value: " << *pNum << std::endl;
    return 0;
}
 
