# Вопрос 12: 

---

- ## [Какие 3 вида шаблонных параметров существуют?](#title1) 
- ## [Раскажите об особенностях специализации шаблонных классов.](#title2)
- ## [Расскажите об особенностях перегрузки и специализации шаблонных функций.](#title3)
- ## [Что такое инстанцирование шаблонов, специализация шаблонов?](#title4) 
- ## [Как использовать шаблоны с переменным количеством аргументов и оператор sizeof…?.](#title5)
- ## [Напишите какую-нибудь простую функцию с использованием variadic templates (print например)](#title6)

---

### <a id="title1">Какие 3 вида шаблонных параметров существуют?</a>

У шаблонов могут быть три параметра :
- _non-type parametr_
- _type parametr_
- _template parametr_

__non-type parametr__

__ОПР:__ Шаблонными параметры, не являющимися типами могут быть только целочисленные типы а также bool и char

Хороший пример класса, который использует такие шаблонные параметры это std::array (обертка над честным массивом).
Зачем это вообще нужно? Чтобы типы от разных констант не были совместимы друг с другом

__template parametr__

Допустим мы пишем свой Stack и хотим передавать в шаблонах какой контейнер использовать, то есть хотим пользоваться им примерно так:

```c++
template <...>
class Stack {
  public:
    ...
  private:
    Container<T> container_;
}

int main() {
    Stack<int, std::vector> s;
}
```

Чтобы это работало нам надо написать объявление нашего класса вот так:

```c++
template <typename T, template <typename U> typename Container>
class Stack {
  public:
    ...
  private:
    Container<T> container_;
}
```

На самом деле U можно не писать, так как этот тип нигде не используется. Тогда наш класс будет выглядеть вот так:

```c++
template <typename T, template <typename> typename Container>
class Stack {
  public:
    ...
  private:
    Container<T> container_;
}
```

---

### <a id="title2">Раскажите об особенностях специализации шаблонных классов.</a>

При определении шаблона класса компилятор сам генерирует по этому шаблону классы, которые применяют определенные типы.

Однако мы сами можем определить подобные классы для конкретного набора параметров шаблона. Подобные определения классов называются специализацией шаблона. 
Специализация шаблона может быть полной и частичной.

Пример _полной специализации_:

```c++
template <typename T>
class Vector {
    ...
}

template <>
class Vector<bool> {
    ...
}
```

Пример _частичной специализации_:

```c++
template <typename T>
class Vector<T*> {
    ...
}

```

У функций так такой особо специализации нет, так как есть перегрузка (более подробно в следующем вопросе).

---

### <a id="title3">Расскажите об особенностях перегрузки и специализации шаблонных функций.</a>

Перегрузка и специализация шаблонных функций имеют некоторые особенности:
- Перегрузка шаблонных функций позволяет определить несколько версий функции с одним именем, но с различными типами аргументов. Компилятор выбирает наиболее подходящую версию функции на основе типов аргументов.
- Специализация шаблонных функций позволяет определить специализированную версию функции для конкретного типа данных.
  Это делается путем создания специализированной версии функции для конкретного типа данных.
  Специализация может быть полной (для всех параметров шаблона) или частичной (для некоторых параметров шаблона).
  При использовании специализации шаблонной функции необходимо явно указать тип данных, для которого создается специализированная версия.

Посмотрим на следующий код (номер функции = то что выводим в поток):

```c++
#include <iostream>

template <typename T, typename U>
void f(T, U) {
    std::cout << 1;
}

template <typename T>
void f(T, T) {
    std::cout << 2;
}

template <>
void f(int, int) {
    std::cout << 3;
}

int main() {
    f(0, 0);
}
```
 
Какая функция вызовется?
>Ответ: вызовется 3 версия

Однако, если мы сделаем небольшую перестановку:

```c++
#include <iostream>

template <typename T, typename U>
void f(T, U) {
    std::cout << 1;
}

template <>
void f(int, int) {
    std::cout << 3;
}

template <typename T>
void f(T, T) {
    std::cout << 2;
}

int main() {
    f(0, 0);
}
```

то вызовется 2 версия!!!

А теперь попробуем разобраться почему так:
- Специализация применилась к 1 функции
- На моменте выбора перегрузки выиграла 2, так как она более частная
- У 2 версии нет специализации, поэтому она вызвалась сама

То есть специализация выбирается уже после выбора перегрузки!

А теперь сделаем вот так:

```c++
#include <iostream>

template <typename T, typename U>
void f(T, U) {
    std::cout << 1;
}

void f(int, int) {
    std::cout << 3;
}

template <typename T>
void f(T, T) {
    std::cout << 2;
}

int main() {
    f(0, 0);
}
```

Теперь опять выберется 3 версия (потому что это уже не специализация, а перегрузка)

---

### <a id="title4">Что такое инстанцирование шаблонов, специализация шаблонов?</a>

__ОПР:__ _Инстанцирование шаблонов_ - это процесс создания конкретной версии шаблона для конкретного типа данных. 
          Во время компиляции, когда шаблонная функция или класс вызывается с конкретными аргументами, компилятор генерирует код для этой конкретной версии шаблона. 
          Различают неявное инстанцирование, которое происходит при вызове функции или создании объекта класса, и явное инстанцирование с помощью резервированного слова template. 
          Инстанцирование можно делать только в точке программы, где доступна реализация шаблона функции или методов шаблонного класса.

```c++
#include <iostream>

template <typename T> T sqr(T);

template <typename T>
class X {
 private:
  T x;

 public:
  X(T x) : x(x) {}
  T get()const;
  void set(T);
};

template <typename T>
T sqr(T x) { return x * x; }

template <typename T>
T X<T>::get() const { return x; }

template <typename T>
void X<T>::set(T x) { this->x=x; }

template double sqr(double); // явное инстанцирование шаблона функции

template int sqr(int);       // для двух типов аргументов

template class X<int>;       // и класса для типа int

int main() {
  std::cout << sqr(10) << "\n";  // OK
  std::cout << sqr(1.2) << "\n"; // OK
  std::cout << sqr(10L) << "\n"; // Ошибка, нет sqr(long)
  
  X<int> x1(10); 
  std::cout << x1.get() << "\n"; // OK
  X<double> x2(1.2); 
  std::cout << x2.get() << "\n"; // Ошибка, нет X<double>::get()
  return 0;
}
```

---

### <a id="title5">Как использовать шаблоны с переменным количеством аргументов и оператор sizeof…?.</a>

Шаблоны с переменным количеством аргументов и оператор sizeof... позволяют работать с произвольным количеством аргументов в шаблоне. 
Они используются вместе с параметрами шаблона pack (parameter pack) и оператором распаковки ... (unpacking operator).

__ОПР:__ _sizeof..._ - это функция которая возвращает количество элементов в parameter pack.

__ОПР:__ _parameter pack_ - это шаблонный параметр который принимает либо ноль параметров либо некоторое их количество (non-types, types, or templates).

Пример использования шаблонов с переменным количеством аргументов:

```c++
template<typename... Args>
void print(Args... args) {
    cout << sizeof...(args) << endl; // выводит количество аргументов
    ((cout << args << " "), ...); // выводит все аргументы
}

int main() {
    print(1, 2, 3); // выводит: 3 1 2 3
    print("Hello", "World"); // выводит: 2 Hello World
    return 0;
}
```

---

### <a id="title6">Напишите какую-нибудь простую функцию с использованием variadic templates (print например)</a>

Пример простой функции с использованием variadic templates (шаблоны с переменным количеством аргументов):

```c+++
template<typename T>
void printValue(T value) {
    cout << value << endl;
}

template<typename T, typename... Args>
void printValue(T value, Args... args) {
    cout << value << " ";
    printValue(args...);
}

int main() {
    printValue(1, 2, 3); // выводит: 1 2 3
    printValue("Hello", "World"); // выводит: Hello World
    return 0;
}
```

---
