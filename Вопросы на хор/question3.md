# Вопрос 3: 

---

- ## [Что такое проблема зависимых имен в шаблонах?](#title1) 
- ## [Расскажите про оба варианта этой проблемы и про их решение. Приведите примеры.](#title2)
- ## [Расскажите про шаблонные параметры шаблонов.](#title3)
- ## [Что это такое и зачем это нужно?](#title4) 

---

### <a id="title1">Что такое проблема зависимых имен в шаблонах?</a>

Посмотрим на следующий код

```c++
template <typename T>
struct S {
    using X = T;
};

template <>
struct S<int> {
    static int X; 
};

int a = 0;

template <typename T>
void f() {
    S<T>::X * a;
}

int main() {
    f<int>();
    f<double>();
}
```

Обратим внимание на строку S::X * a
Эта строка может принимать разный синтаксический смысл в зависимости от T (либо declaration (указатель) либо expression (умножение)), поэтому такой код не скомпилируется (для разных типов это будет то выражение то объявление)
Собственно это и есть "проблема зависимых имен", здесь X зависит от T.

Есть следующее правило: если компилятор встречает зависимое имя и не может понять что это, то он по умолчанию считает что expression, поэтому если вызвать только f() то все будет ок.

Если нужно чтобы компилятор парсил зависимое имя как declaration, то нужно написать typename (это вторая роль слова typename в C++)

```c++
...

template <typename T>
void f() {
    typename S<T>::X * a; // теперь переменная а является указателем типом S<T>::X
}
```

Посмотрим на еще один интересный пример

```c++
template <typename T>
struct S {
    template <int M, int N>
    struct A{};
}

template <>
struct S<int> {
    static const int A = 0;
}

template <typename T>
void f() {
    S<T>::A<1,2> a;
}
```

Тогда в строке S<T>::A<1,2> a; опять возникнет неодназначность
- Ее можно понять как объявление переменной a типа S<T>::A<1,2>
- Ее можно понять как S<T>::A <(меньше) 1 , 2 >(больше) a

А теперь самое забавное:
Даже если мы добавим слово typename код

```c++
template <typename T>
struct S {
    template <int M, int N>
    struct A{};
}

template <>
struct S<int> {
    static const int A = 0;
}

template <typename T>
void f() {
    typename S<T>::A<1,2> a;
}
```

все равно не скомпилируется, потому что слово typename лишь означает что дальше будет название типа, а не шаблон. Чтобы это пофиксить нужно переписать функцию f вот так:

```c++
template <typename T>
void f() {
    typename S<T>::template A<1,2> a; // теперь переменная а является типом S<T>::A с шаблоном
}
```

то есть у слова template тоже два значения в языке C++

---

### <a id="title2">Расскажите про оба варианта этой проблемы и про их решение. Приведите примеры.</a>

[выше](#title2)

---

### <a id="title3">Расскажите про шаблонные параметры шаблонов.</a>

[в конце вопроса 4 из УД](https://github.com/HappyARL/cpp-guide/blob/main/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B%20%D0%BD%D0%B0%20%D0%A3%D0%94/question4.md)

---

### <a id="title4">Что это такое и зачем это нужно?</a>

[в конце вопроса 4 из УД](https://github.com/HappyARL/cpp-guide/blob/main/%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B%20%D0%BD%D0%B0%20%D0%A3%D0%94/question4.md)

---
