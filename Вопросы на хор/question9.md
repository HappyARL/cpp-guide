# Вопрос 9: 

---
  
- ## [Что делает и как реализована функция std::move?](#title1) 
- ## [Расскажите почему наивное определение lvalue и rvalue (положение от знака равно) неверное.](#title2)
- ## [Формально определите rvalue и lvalue. Расскажите об rvalue-ссылках.](#title3) 
- ## [Какие присваивания между lvalue-, rvalue-ссылками, а также временными объектами и именованными нессылочными объектами разрешены, а какие запрещены?](#title4) 
- ## [Что меняется в случае с константными ссылками и объектами?](#title5) 
- ## [Что такое RVO и copy elision??](#title6) 
- ## [Приведите примеры, иллюстрирующие все вышесказанное.](#title7) 

---

### <a id="title1">Что делает и как реализована функция std::move?</a>

[код](https://gitlab.com/yaishenka/cpp_course/-/blob/main/lectures/lecture_16.md#9-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-stdmove)

---

### <a id="title2">Расскажите почему наивное определение lvalue и rvalue (положение от знака равно) неверное.</a>

Неформально мы уже говорили про эти понятия: lvalue - то что может стоять слева от =, rvalue - то что не может. На самом деле такое определение неверное, причем в обе стороны
-Пример в одну сторону: объект, у которого не определен оператор присваивания не может стоять слева от =, хотя он lvalue
-Пример в другую сторону: BitReference в vector<bool>. Это rvalue (временно созданный объект) однако он стоял слева от =

```c++
BitRef operator[](size_t i) {
  return BitReference(arr_ + i / 8, i % 8);
}
```

---

### <a id="title3">Формально определите rvalue и lvalue. Расскажите об rvalue-ссылках.</a>

[__ОПР:__ _rvalue and lvalue_](https://ru.cppreference.com/w/cpp/language/value_category)
[об rvalue-ссылках](https://gitlab.com/yaishenka/cpp_course/-/blob/main/lectures/lecture_16.md#9-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-stdmove)

---

### <a id="title4">Какие присваивания между lvalue-, rvalue-ссылками, а также временными объектами и именованными нессылочными объектами разрешены, а какие запрещены?</a>

[об rvalue-ссылках](https://gitlab.com/yaishenka/cpp_course/-/blob/main/lectures/lecture_16.md#9-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-stdmove)

---

### <a id="title5">Что меняется в случае с константными ссылками и объектами?</a>

Между lvalue-ссылками и именованными нессылочными объектами разрешено присваивание. Это означает, что вы можете присвоить значение нессылочного объекта lvalue-ссылке.

Между rvalue-ссылками и временными объектами также разрешено присваивание. Rvalue-ссылки предназначены для привязки к временным объектам, поэтому вы можете присвоить временный объект rvalue-ссылке.

Однако присваивание между временными объектами запрещено. Временные объекты являются rvalues, и по стандарту C++ rvalues не могут быть присвоены друг другу.

Когда речь идет о константных ссылках и объектах, присваивание между константной ссылкой и временным объектом разрешено. Константная ссылка может быть привязана к временному объекту, но этот объект не может быть изменен через ссылку.

Присваивание между константными ссылками запрещено. Константная ссылка предназначена для привязки к неизменяемым объектам, поэтому вы не можете присвоить значение константной ссылке.

В целом, присваивание между lvalue-ссылками и именованными нессылочными объектами, а также между rvalue-ссылками и временными объектами разрешено. Однако присваивание между временными объектами и присваивание константным ссылкам запрещено.

---

### <a id="title6">Что такое RVO и copy elision??</a>

RVO (Return Value Optimization) и copy elision (оптимизация копирования) - это оптимизации, которые компилятор может применить для избежания лишних копирований объектов при возвращении значений из функции.

RVO - это оптимизация, при которой компилятор пропускает создание временного объекта при возвращении значения из функции. Вместо этого, компилятор напрямую конструирует объект-получатель в месте вызова функции. Это позволяет избежать копирования объекта и улучшает производительность программы.

Copy elision - это оптимизация, при которой компилятор пропускает создание временных объектов при передаче аргументов в функцию или при инициализации переменных. Вместо этого, компилятор напрямую конструирует объект-получатель с помощью передаваемого объекта. Это также позволяет избежать копирования объекта и улучшает производительность программы.

Обе оптимизации позволяют избежать лишних операций копирования и перемещения объектов, что может значительно ускорить выполнение программы. Они особенно полезны при работе с большими или сложными объектами, где копирование может быть затратным по времени или ресурсам.

---

### <a id="title7">Приведите примеры, иллюстрирующие все вышесказанное.</a>

выше

---

