# Вопрос 10: 
   
---
  
- ## [Что такое универсальная ссылка?](#title1) 
- ## [Расскажите о правилах вывода шаблонов в случае универсальных ссылок.](#title2)
- ## [Расскажите о том, что такое “идеальная передача” (perfect forwarding).](#title3) 
- ## [Расскажите про функцию std::forward (без реализации).](#title4) 
- ## [Как использовать эту функцию на примере emplace_back?](#title5) 

---

### <a id="title1">Что такое универсальная ссылка?</a>

__ОПР:__ _Универсальной сслыкой_ понимается следующее - Если шаблонная функция иммет типом параметра T&&, где Т этоп ее шаблонного аргумента, то такая функция принимает как и lvalue так и rvalue.

```c++
void f(int& x); -> only lvalue

void f(int&& x) -> only rvalue

template <typename T>
void g(T&& x) -> both lvalue and rvalue
```

[подробнее](https://gitlab.com/yaishenka/cpp_course/-/blob/main/lectures/lecture_16.md#8-%D1%83%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8-%D0%B8-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D1%81%D0%B6%D0%B0%D1%82%D0%B8%D1%8F-%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA)

### <a id="title2">Расскажите о правилах вывода шаблонов в случае универсальных ссылок.</a>

Оно очень простое: одиночный & всегда побеждает. То есть:

1. & и & это &
2. && и & это &
3. & и && это &
4. && и && это &&

---

### <a id="title3">Расскажите о том, что такое “идеальная передача” (perfect forwarding).</a>

__ОПР:__ _Идеальная передача (perfect forwarding)_ - это механизм в C++, который позволяет передавать аргументы функции так, чтобы их тип и значение сохранялись без изменений. Это особенно полезно при передаче аргументов шаблонных функций или функций, которые должны принимать произвольное количество аргументов.

---

### <a id="title4">Расскажите про функцию std::forward (без реализации).</a>

__ОПР:__ Функция _std::forward_ является частью стандартной библиотеки C++ и используется вместе с идеальной передачей. Она позволяет передавать аргументы функции с сохранением их rvalue или lvalue категории. 

std::forward принимает один аргумент - ссылку на объект, который нужно передать. Внутри функции std::forward происходит проверка типа аргумента. Если аргумент является rvalue, то std::forward возвращает rvalue-ссылку на этот объект. Если аргумент является lvalue, то std::forward возвращает lvalue-ссылку на этот объект. Таким образом, std::forward позволяет передавать аргументы с сохранением их категории.

```c++
template <typename T>
T&& forward(std::remove_reference_t<T>& x) noexcept {
  return static_cast<T&&>(x);
}
```

---

### <a id="title5">Как использовать эту функцию на примере emplace_back?</a>

```c++
template <typename... Args>
void emplace_back(Args&& args) {
  if (size_ == capacity_) {
    reserve(2 * capacity_);
  }

  new(arr + sz) T(std::forward<Args>(args)...);
  size_ += 1;
}
```

Давайте разберем случаи:

Первый:

__arg = lvalue -> Arg = type& -> decltype(arg) = type& -> T = type& -> x = type& -> T&& = type&__

Второй:

__arg = rvalue -> Arg = type -> decltype(arg) = type&& -> T = type -> x = type& -> T&& = type&&__

Теперь мы муваем аргументы, которые можем. А остальные копируем

---
