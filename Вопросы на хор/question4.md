# Вопрос 4: 

---
  
- ## [Каковы правила видимости родителей и их полей и методов при двухуровневом наследовании, как действует слово friend в этих ситуациях?](#title1) 
- ## [Что такое множественное наследование, в чем заключается проблема ромбовидного наследования, что такое виртуальное наследование?](#title2)
- ## [Что означает и как возникает ошибка “ambiguous base”?](#title3)
- ## [Что означает и как возникает “warning: inaccessible base class”?](#title4)
- ## [Зачем нужен std::dynamic_cast?](#title5)

---

### <a id="title1">Каковы правила видимости родителей и их полей и методов при двухуровневом наследовании, как действует слово friend в этих ситуациях?</a>

Правила видимости родителей и их полей и методов при двухуровневом наследовании в C++ следующие:
1. При наследовании от нескольких базовых классов, поля и методы базовых классов становятся доступными в производном классе с помощью оператора разрешения области видимости (::). Если есть конфликт имен, необходимо явно указать, из какого базового класса нужно использовать поле или метод.
2. Поля и методы, определенные в производном классе, имеют более высокий приоритет, чем поля и методы с тем же именем из базовых классов. Если в производном классе определено поле или метод с тем же именем, что и в базовых классах, то будет использоваться определение из производного класса.
3. Если в производном классе не определено поле или метод с тем же именем, что и в базовых классах, то будет использоваться определение из ближайшего базового класса.

Слово _friend_ влияет на правила видимости родителей и их полей и методов при двухуровневом наследовании следующим образом:
1. Если класс A объявляет класс B как друга (friend class B), то класс B имеет доступ к закрытым и защищенным членам класса A, включая его родительские классы.
2. Если класс A объявляет функцию F как друга (friend void F()), то функция F имеет доступ к закрытым и защищенным членам класса A, включая его родительские классы.
3. Ключевое слово friend не наследуется. То есть, если класс B наследует от класса A, который объявлен как друг класса C, то класс B не имеет доступа к закрытым и защищенным членам класса C.
4. Ключевое слово friend не влияет на правила видимости полей и методов базовых классов при двухуровневом наследовании.

---

### <a id="title2">Что такое множественное наследование, в чем заключается проблема ромбовидного наследования, что такое виртуальное наследование?</a>

В C++ можно наследоваться сразу от нескольких классов:

```c++
struct Mom {};
struct Dad {};
struct Son: Mom, Dad {};
```

Размещение в памяти работает по следующему принципу: сначала родители в том порядке, в котором они унаследованы, потом наследники. С конструкторами и деструкторами тоже самое.
С множественным наследованием приходит интересная особенность: указатель на родителя и на наследника могут численно не совпадать:

```c++
int main() {
  Son s;
  Dad* d = &s;
}
```

При этом d и &s численно не совпадают (потому что Dad лежит в Son правей начала на sizeof(Mom) )

Теперь стоит обсудить проблему ромбовидного наследования __(Diamond problem)__

Допустим у нас есть следующая иерархия наследования:

```c++
struct Granny {
  int x;
};

struct Mother: Granny {
  int y;
};

struct Dad: Granny {
  int z;
}

struct Son: Mother, Dad {
  int t;
};
```

Проблема в следующем: в сыне сейчас будет лежать 5 интов. То есть в памяти он будет выглядеть следующим образом:

```c++
Mother (Granny, int)
Dad (Granny, int)
int
```

Тогда следующий код будет приводить к ошибке:

```c++
int main() {
  Son s;
  s.x; // CE, ambiguous 
}
```

В сыне два x и непонятно к какому обращаться (тоже самое было бы с методами).

Каст к бабушке тоже CE:

```c++
int main() {
  Son s;
  Granny& g = s; // CE
}
```

Можно обращаться к конкретным бабушкам через промежуточный каст к маме/папе. Можно еще обратиться к конкретному полю:

```c++
int main() {
  Son s;
  s.Mom::x;
}
```

Еще вот такой пример:

```c++
struct Granny {};
struct Mom: Granny {};
struct Son: Mom, Granny {};
```

В данном случае ко второй бабушке можно обратиться только через трюки с _reinterpret_cast_ и сдвигами указателей.

 __! Замечание:__ такая ситуация называется [inaccessible base class](#title4).

>Виртуальное наследование
>
Этот способ наследования позволяет решить проблему ромбовидного наследования. 
Напомним, что по умолчанию если в иерархии наследования несколько раз присутствует один и тот же класс, то в итоге в памяти это будут разные объекты этого класса.

```c++
struct Granny {};
struct Mom: public virtual Granny {};
struct Dad: public virtual Granny {};
struct Son: Mom, Son {};
```

Теперь в Son будет лежать одна копия Granny (она будет общей для Dad и Mom). Это реализовано через хранения указателя на общего предка.

---

### <a id="title3">Что означает и как возникает ошибка “ambiguous base”?</a>

__ОПР:__ _Ошибка "ambiguous base"_ означает, что в производном классе есть несколько базовых классов с одинаковыми именами, и компилятор не может определить, из какого базового класса нужно использовать поле или метод. 
          Это может возникнуть при множественном наследовании, когда два или более базовых класса имеют одинаковые имена.

Рассмотрим код который был ранее, тут пример данной ошибки:

```c++
int main() {
  Son s;
  s.x; // CE, ambiguous 
}
```

---

### <a id="title4">Что означает и как возникает “warning: inaccessible base class”?</a>

__ОПР:__ _Предупреждение "inaccessible base class"_ означает, что базовый класс является недоступным для производного класса из-за его модификатора доступа. 
          Это может возникнуть, если базовый класс объявлен как закрытый или защищенный, и производный класс пытается получить доступ к его членам.

---

### <a id="title5">Зачем нужен std::dynamic_cast?</a>

__ОПР:__ _std::dynamic_cast_ - это оператор приведения типа в C++, который позволяет выполнять безопасное приведение указателей или ссылок на объекты между классами в иерархии наследования. 
          Он используется для проверки возможности приведения указателя или ссылки на базовый класс к указателю или ссылке на производный класс. 
          Если приведение невозможно, то std::dynamic_cast возвращает нулевой указатель (nullptr) для указателя или ссылку на недействительный объект. 
          Это полезно, когда нужно проверить тип объекта во время выполнения программы.

[подробнее тут](https://gitlab.com/yaishenka/cpp_course/-/blob/main/lectures/lecture_10.md#5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B2-%D1%80%D0%B0%D0%BD%D1%82%D0%B0%D0%B9%D0%BC%D0%B5-dynamic_cast)

---

